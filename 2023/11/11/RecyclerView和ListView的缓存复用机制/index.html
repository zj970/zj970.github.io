<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RecyclerView和ListView的缓存复用机制 | 落雪のBlog</title><meta name="author" content="zj970"><meta name="copyright" content="zj970"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景&amp;emsp;&amp;emsp;Android对于列表View的渲染和使用，常用的控件为ListView和RecyclerView。 适配器使用ListView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Wi">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView和ListView的缓存复用机制">
<meta property="og:url" content="https://www.serendipity.fit/2023/11/11/RecyclerView%E5%92%8CListView%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="落雪のBlog">
<meta property="og:description" content="背景&amp;emsp;&amp;emsp;Android对于列表View的渲染和使用，常用的控件为ListView和RecyclerView。 适配器使用ListView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Wi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp">
<meta property="article:published_time" content="2023-11-11T03:30:12.000Z">
<meta property="article:modified_time" content="2024-01-22T09:40:28.410Z">
<meta property="article:author" content="zj970">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RecyclerView和ListView的缓存复用机制",
  "url": "https://www.serendipity.fit/2023/11/11/RecyclerView%E5%92%8CListView%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/",
  "image": "https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp",
  "datePublished": "2023-11-11T03:30:12.000Z",
  "dateModified": "2024-01-22T09:40:28.410Z",
  "author": [
    {
      "@type": "Person",
      "name": "zj970",
      "url": "https://www.serendipity.fit"
    }
  ]
}</script><link rel="shortcut icon" href="https://gitee.com/zhou-jian1234/resource/raw/master/paper/favicon.webp"><link rel="canonical" href="https://www.serendipity.fit/2023/11/11/RecyclerView%E5%92%8CListView%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RecyclerView和ListView的缓存复用机制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zj970/resource/personal/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">落雪のBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">RecyclerView和ListView的缓存复用机制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RecyclerView和ListView的缓存复用机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-11T03:30:12.000Z" title="发表于 2023-11-11 11:30:12">2023-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-22T09:40:28.410Z" title="更新于 2024-01-22 17:40:28">2024-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>&emsp;&emsp;Android对于列表View的渲染和使用，常用的控件为ListView和RecyclerView。</p>
<h1 id="适配器使用"><a href="#适配器使用" class="headerlink" title="适配器使用"></a>适配器使用</h1><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WifiAdapter</span> <span class="keyword">extends</span> <span class="title class_">ArrayAdapter</span>&lt;ScanResult&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WifiAdapter</span><span class="params">(Context context, <span class="type">int</span> resource, List&lt;ScanResult&gt; objects)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, resource, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取适配器控件中的View对象，得到用于展示数据的视图 int position,：当前item的下标 View convertView,</span></span><br><span class="line"><span class="comment">     * 表示可复用的View ViewGroup parent 当前绘制的item 所属的listview</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;</span><br><span class="line">        <span class="type">ScanResult</span> <span class="variable">item</span> <span class="operator">=</span> getItem(position);</span><br><span class="line">        WifiHolder holder;</span><br><span class="line">        <span class="comment">// 表示第一次运行创建，否则复用view</span></span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">            convertView = LayoutInflater.from(getContext()).inflate(R.layout.network_item, parent, <span class="literal">false</span>);</span><br><span class="line">            holder = <span class="keyword">new</span> <span class="title class_">WifiHolder</span>();</span><br><span class="line">            holder.wifi_image = convertView.findViewById(R.id.wifi_image);</span><br><span class="line">            holder.wifi_name = convertView.findViewById(R.id.wifi_name);</span><br><span class="line">            holder.wifi_type = convertView.findViewById(R.id.wifi_type);</span><br><span class="line">            convertView.setTag(holder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进行复用</span></span><br><span class="line">            holder = (WifiHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        holder.wifi_name.setText(item.SSID);</span><br><span class="line">        <span class="type">String</span> <span class="variable">capabilities</span> <span class="operator">=</span> item.capabilities;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(capabilities)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (capabilities.contains(<span class="string">&quot;WPA&quot;</span>) || capabilities.contains(<span class="string">&quot;wpa&quot;</span>)) &#123;</span><br><span class="line">                holder.wifi_image.setImageResource(NetworkUtil.wifiLevelLock[getLevel(item.level)]);</span><br><span class="line">                holder.wifi_type.setText(<span class="string">&quot;WPA&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capabilities.contains(<span class="string">&quot;WEP&quot;</span>) || capabilities.contains(<span class="string">&quot;wep&quot;</span>)) &#123;</span><br><span class="line">                holder.wifi_image.setImageResource(NetworkUtil.wifiLevelLock[getLevel(item.level)]);</span><br><span class="line">                holder.wifi_type.setText(<span class="string">&quot;WEP&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                holder.wifi_image.setImageResource(NetworkUtil.wifiLevelUnLock[getLevel(item.level)]);</span><br><span class="line">                holder.wifi_type.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WifiHolder</span> &#123;</span><br><span class="line"></span><br><span class="line">        ImageView wifi_image;</span><br><span class="line">        TextView wifi_name;</span><br><span class="line">        TextView wifi_type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">(<span class="type">int</span> mRssi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRssi == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> WifiManager.calculateSignalLevel(mRssi, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zj970</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: App列表适配器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 9/19/23 4:41 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalAppItemAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;LocalAppItemAdapter.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> LocalAppItemAdapter.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AppResponse.AppBean&gt; appInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IViewListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalPresenter presenter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalAppItemAdapter</span><span class="params">(IViewListener listener, LocalPresenter presenter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.listener = listener;</span><br><span class="line">        <span class="built_in">this</span>.presenter = presenter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppInfoList</span><span class="params">(List&lt;AppResponse.AppBean&gt; appInfoList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appInfoList.clear();</span><br><span class="line">        <span class="built_in">this</span>.appInfoList.addAll(appInfoList);</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAt</span><span class="params">(AppResponse.AppBean info)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> appInfoList.indexOf(info);</span><br><span class="line">        <span class="built_in">this</span>.appInfoList.remove(info);</span><br><span class="line">        notifyItemRemoved(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(parent.getContext()).inflate(R.layout.item_app_common, parent, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewHolder</span>(view);</span><br><span class="line">        <span class="keyword">return</span> viewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;SetTextI18n&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        AppResponse.<span class="type">AppBean</span> <span class="variable">info</span> <span class="operator">=</span> appInfoList.get(position);</span><br><span class="line">        holder.mTVAppName.setText(info.getLabel());</span><br><span class="line">        holder.mTVAppVersion.setText(BApplication.getmContext().getText(R.string.version_app)</span><br><span class="line">                + <span class="string">&quot;:&quot;</span> + info.getCurrentVersion() + <span class="string">&quot;-----&gt;&quot;</span> + info.getVersionCode());</span><br><span class="line">        holder.mIVAppIcon.setImageDrawable(info.getDrawable());</span><br><span class="line">        holder.mCFP.setAnimation(<span class="literal">true</span>);</span><br><span class="line">        holder.mCFP.showPercentText(<span class="literal">false</span>);</span><br><span class="line">        holder.itemView.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                listener.onclick(holder.itemView, info, presenter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appInfoList != <span class="literal">null</span> ? appInfoList.size() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line">        ImageView mIVAppIcon;</span><br><span class="line">        ImageView mIVAppStatus;</span><br><span class="line">        TextView mTVAppName;</span><br><span class="line">        TextView mTVAppVersion;</span><br><span class="line">        TextView mTVState;</span><br><span class="line">        ColorfulProgressbar mCFP;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ViewHolder</span><span class="params">(<span class="meta">@NonNull</span> View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            mIVAppIcon = itemView.findViewById(R.id.mIVAppIcon);</span><br><span class="line">            mTVAppName = itemView.findViewById(R.id.mTVAppName);</span><br><span class="line">            mTVAppVersion = itemView.findViewById(R.id.mTVAppVersion);</span><br><span class="line">            mIVAppStatus = itemView.findViewById(R.id.mIVAppStatus);</span><br><span class="line">            mTVState = itemView.findViewById(R.id.mTVState);</span><br><span class="line">            mCFP = (ColorfulProgressbar) itemView.findViewById(R.id.mCFP);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IViewListener</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">(View view, AppResponse.AppBean info, LocalPresenter filePresenter)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="使用RecyclerView添加子控件点击响应事件数据紊乱"><a href="#使用RecyclerView添加子控件点击响应事件数据紊乱" class="headerlink" title="使用RecyclerView添加子控件点击响应事件数据紊乱"></a>使用RecyclerView添加子控件点击响应事件数据紊乱</h2><ul>
<li>代码片段</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">info</span> <span class="operator">=</span> mData.get(position);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">if</span>(info.getType() == <span class="number">0</span>)<span class="comment">//当类型为0不响应此事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        holder.itemView.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                listener.onclick(info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码当时撰写测试的时候感觉是没有问题，可在后续测试中出现了明明点击的是Data B渲染的视图View，但是响应的是Data A的数据，后续通过阅读代码，发现是RecyclerView的复用机制导致的，以下是代码修改: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">info</span> <span class="operator">=</span> mData.get(position);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">if</span>(info.getType() == <span class="number">0</span>)<span class="comment">//当类型为0不响应此事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        holder.itemView.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                listener.onclick(mData.get(holder.getAdapterPosition()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里使用了holder.getAdapterPostion()来获取精准的的位置信息，对于此方法的描述，官方的文档进行了详细阐述，经过测试发现响应的数据和渲染的数据终于一致。  </p>
<blockquote>
<p>Returns the Adapter position of the item represented by this ViewHolder.<br>Note that this might be different than the getLayoutPosition() if there are pending adapter updates but a new layout pass has not happened yet.<br>RecyclerView does not handle any adapter updates until the next layout traversal. This may create temporary inconsistencies between what user sees on the screen and what adapter contents have. This inconsistency is not important since it will be less than 16ms but it might be a problem if you want to use ViewHolder position to access the adapter. Sometimes, you may need to get the exact adapter position to do some actions in response to user events. In that case, you should use this method which will calculate the Adapter position of the ViewHolder.<br>Note that if you’ve called RecyclerView.Adapter.notifyDataSetChanged(), until the next layout pass, the return value of this method will be NO_POSITION.<br>Returns:<br>The adapter position of the item if it still exists in the adapter. NO_POSITION if item has been removed from the adapter, RecyclerView.Adapter.notifyDataSetChanged() has been called after the last layout pass or the ViewHolder has already been recycled.</p>
</blockquote>
<p>&emsp;&emsp;但是，功能在后续的测试中又出现了问题，有些视图ItemView明明是可以点击响应的，却无法响应，又做了如下更改： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">info</span> <span class="operator">=</span> mData.get(position);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">if</span>(info.getType() == <span class="number">0</span>)<span class="comment">//当类型为0不响应此事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        holder.itemView.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                listener.onclick(mData.get(holder.getAdapterPosition()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 清除不需要的点击事件或设置默认的点击事件</span></span><br><span class="line">        holder.itemView.setOnClickListener(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="type">Data</span> <span class="variable">info</span> <span class="operator">=</span> mData.get(position);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    holder.itemView.setOnClickListener(v -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(info.getType() == <span class="number">0</span>)<span class="comment">//当类型为0不响应此事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                listener.onclick(mData.get(holder.getAdapterPosition()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;经历这几次波折，对于RecyclerView和ListView的缓存机制不甚了解，故做以下笔记。</p>
<hr>
<h1 id="延伸学习"><a href="#延伸学习" class="headerlink" title="延伸学习"></a>延伸学习</h1><ul>
<li>参考文章<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1eaaccd169e4#:~:text=ListView%20%E5%92%8C%20RecyclerView%20%E7%9A%84%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E8%BF%98%E6%98%AF%E6%9C%89%E5%BE%88%E5%A4%A7%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%8C%20ListView,%E7%9A%84%E5%A4%8D%E7%94%A8%E6%98%AF%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%8C%E8%80%8C%20RecyclerView%20%E6%98%AF%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E5%8F%82%E8%80%83%E4%BA%86%20%E8%85%BE%E8%AE%AFBugly%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB%20%E9%87%8C%E9%9D%A2%E8%AF%A6%E7%BB%86%E6%AF%94%E8%BE%83%E4%BA%86%E8%BF%99%E4%B8%A4%E8%80%85%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82">虚心学习的小来子</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/RGogoing/p/5554086.html">代码如风的</a></li>
</ul>
</li>
</ul>
<h2 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h2><p>&emsp;&emsp;首先了解一些概念，ActiveView其实就是在UI屏幕上可见的视图(onScreenView)，也就是与用户进行交互的View，而有些View滑动到屏幕外面(offScrenView)那么这些View就变成了ScrapView，这些View已经无法与用户进行交互了，自然UI视图改变的时候就不需要再去重新绘制。但是这些View并没有被销毁掉，而是存储起来。目地就是为了二次复用。</p>
<ul>
<li>ListView的两级缓存</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>是否 createView</th>
<th>是否 bindView</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>mActiveViews</td>
<td>否</td>
<td>否</td>
<td>用于屏幕内快速复用</td>
</tr>
<tr>
<td>mScrapViews</td>
<td>否</td>
<td>是</td>
<td></td>
</tr>
</tbody>
</table>

<p>&emsp;&emsp;<b>mActiveViews</b>是一个保存可以屏幕内可见、可以直接复用的View数组(AbsListView.java)。假如说有这样一个场景，屏幕里面可以完整的容纳六个View，往下滑动的时候，第0个位置的View被滑出了屏幕，但是mActiveViews数组里面还有5个可以被快速复用。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upload-images.jianshu.io/upload_images/6268659-8559c9cdd1da5c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="image.png"></p>
<p>&emsp;&emsp;<b>mScrapViews</b>是一个保存溢出屏幕View的数组，移到这里的View都会恢复一个空白的View,同时也恢复所有的状态(恢复到刚创建时的状态)。</p>
<ul>
<li>RecyclerView的四级缓存</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>是否 createView</th>
<th>是否 bindView</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>mAttachedScrap</td>
<td>否</td>
<td>否</td>
<td>用于屏幕内快速复用</td>
</tr>
<tr>
<td>mCachedViews</td>
<td>否</td>
<td>否</td>
<td>static final int DEFAULT_CACHE_SIZE = 2</td>
</tr>
<tr>
<td>mViewCashExtension</td>
<td>不研究</td>
<td>不研究</td>
<td></td>
</tr>
<tr>
<td>mRecyclerPool</td>
<td>否</td>
<td>是</td>
<td>static final int DEFAULT_MAX_SCRAP = 5</td>
<td></td>
</tr>
</tbody>
</table>

<p>&emsp;&emsp;<b>mAttachedScrap</b>和ListView的mActivityViews相似，但是复用的东西不同，ListView复用的是View，<font color=red>也就是实现ListView的Adapter的时候实现getView方法的参数convertView</font>，但是RecyclerView复用的对象是ViewHolder，ListView也可以自己实现ViewHolder。   </p>
<p>&emsp;&emsp;<b>mCachedViews和mRecyclerPool</b>这两个加起来实现的效果和ListView的mScrapViews差不多，不过相对于mScrapView做了一个分级缓存，先回收到mCachedViews，这里不会变成初始化形态，但是mCachedViews超过规定的数量时，会把最老的那个转到mRecyclerPool里面，相当于ListView的mScrapViews，ViewHolder所有属性和状态都会被还原，当然在理论上实现多个RecyclerView共用一个mRecyclerPool，可以节省内存。</p>
<h2 id="2-ViewHolder的复用概念"><a href="#2-ViewHolder的复用概念" class="headerlink" title="2. ViewHolder的复用概念"></a>2. ViewHolder的复用概念</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images2015.cnblogs.com/blog/734980/201612/734980-20161207101444288-1931079409.png" alt="image.png"></p>
<p>&emsp;&emsp;ViewHolder 和复用机制没有什么直接的关系。用 getView 的时候会 findViewById ，这无疑是很浪费时间的。ViewHolder 是用来保持着 convertView 对里面每个子 View 的引用。</p>
<ul>
<li>ListView和RecyclerView是先复用再回收。</li>
</ul>
<h3 id="ListView-的复用步骤"><a href="#ListView-的复用步骤" class="headerlink" title="ListView 的复用步骤"></a>ListView 的复用步骤</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upload-images.jianshu.io/upload_images/6268659-e49a8c59bbaf57c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/513/format/webp" alt="ListView复用过程.png"></p>
<h3 id="RecyclerView-的复用步骤"><a href="#RecyclerView-的复用步骤" class="headerlink" title="RecyclerView 的复用步骤"></a>RecyclerView 的复用步骤</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://upload-images.jianshu.io/upload_images/6268659-960be4d65c743072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="RecyclerView复用过程.png"></p>
<h3 id="ListView-的回收"><a href="#ListView-的回收" class="headerlink" title="ListView 的回收"></a>ListView 的回收</h3><p>&emsp;&emsp;完全滑出屏幕后就把 View 回收到 mScrapeViews 当中去，并把 View 还原成初始状态，所以说 ListView 中所有进行复用的 View 的数量加起来一定是一个定值，其大小和屏幕所能容纳下的 item 的个数有关。</p>
<h3 id="RecyclerView-的回收"><a href="#RecyclerView-的回收" class="headerlink" title="RecyclerView 的回收"></a>RecyclerView 的回收</h3><p>&emsp;&emsp;RecyclerView 的回收过程就是一个标准的二级缓存，滑出屏幕的 ViewHolder 先缓存进 mCacheViews ，此时并不还原视图，当 mCacheViews 中的数量超过一定的限制以后（默认是2个，这个是可以由自己来决定的），将最先放入 mCacheViews 的 ViewHolder 放入到 mRecyclerPool 当中去，并且是根据 View 的 type 不同，放入不同的 mRecyclerPool 当中去，同时 mRecyclerPool 也有大小的限制（默认是 5 个），但是这种回收机制好处就在于可以保证 mCacheViews 和 mRecyclerPool 是最新的放到前面。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.serendipity.fit">zj970</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.serendipity.fit/2023/11/11/RecyclerView%E5%92%8CListView%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/">https://www.serendipity.fit/2023/11/11/RecyclerView和ListView的缓存复用机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.serendipity.fit" target="_blank">落雪のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post-share"><div class="social-share" data-image="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/11/11/AndroidTv%E9%83%A8%E5%88%86%E9%A1%B5%E9%9D%A2%E6%8C%89%E9%94%AE%E9%9F%B3%E6%97%A0%E6%95%88/" title="AndroidTv部分页面按键音无效"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">AndroidTv部分页面按键音无效</div></div><div class="info-2"><div class="info-item-1">  Android Tv 部分页面按键音无效，dispatchKeyEvent分发被拦截&emsp;&emsp;开始阅读之前，可以简单了解一下这些大佬的文章。    c枫_撸码的日子   Android 按键处理一 （基础知识） Android 按键处理二 （按键流程之内核层篇） Android 按键处理三 （按键流程之framework）   空杯的境界 Android 按键事件(KeyEvent)的分发机制   小羊子说 Android TV中按键事件和焦点处理总结   圆周率X Android dispatchKeyEvent事件分发详解，简单易懂    问题描述&emsp;&emsp;接入喇叭，进入应用，突然发现一些页面有系统调用的按键提示音，而有些页面则没有。(最终发现是使用了Scrollview出的bug) 问题分析&emsp;&emsp;既然按键声音没有发出，那首先需要了解一下按键声音是怎么发出的。当用户注册了clickListener，则调用发出playSoundEffect()和响应用户写好的onClick()方法。首先排除系统设置声音无效。可以使用adb命令 ...</div></div></div></a><a class="pagination-related" href="/2022/12/31/%E7%A6%BB%E5%88%AB2022/" title="离别2022"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">离别2022</div></div><div class="info-2"><div class="info-item-1">第一行代码 Android 第2版 郭霖著 第1章 开启启程——你的第一行Android代码 第2章 先从看得到的入手——探究活动 第3章 软件也要拼脸蛋——UI开发的点点滴滴 第4章 手机平板要兼顾——探究碎片 第5章 全局大喇叭——详解广播机制 第6章 数据存储全方案——详解持久化技术 第7章 跨程序共享数据——探究内容提供器 第8章 丰富你的程序——运用手机多媒体 第9章 看看精彩的世界——使用网络技术 第10章 后台默默的劳动者——探究服务 第11章 Android特色开发——基于位置的服务 第12章 最佳的UI体验——MaterialDesign实战 第13章 继续进阶——你还应该掌握的高级技巧 第14章 进入实战——开发酷欧天气 第15章 最后一步——将应用发布到360应用商店  总结&emsp;&emsp;观看郭老师的第一行代码书籍，始于7月终于12月。从一个懵懂无知的Android小白，如今总算入了门。恰逢2023年元旦来临之际，感触颇多。&emsp;&emsp;还记得刚接触Android时配置环境的手忙脚乱，踩了很多坑。比如jdk、gradle、gradle p...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/12/13/Android-14-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BActivityManagerService/" title="Android_14_源码分析之ActivityManagerService"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-13</div><div class="info-item-2">Android_14_源码分析之ActivityManagerService</div></div><div class="info-2"><div class="info-item-1"> 前序 一个人知道自己为什么而活，便能忍受任何一种生活      参考博客 厚雪长坡-ActivityTaskManagerService解析 LeeDuo-深入理解ActivityManagerService 芒果蒲公英-Android14 AMS启动流程 anly_jun-探索Activity之启动Intent Flag和taksAffinity menghaocheng-Android-AMS】ActivityManagerService启动分析 Sukai’s Blog  &emsp;&emsp;本文中的所有内容大部分来源于网络资料，如有侵权请联系本人修改或删除，请大家多多支持原创!非常感谢！ ActivityManagerService&emsp;&emsp;Android系统非常庞大、错综复杂，其底层是采用Linux作为基底，上层采用包含虚拟机的Java层以及Native层，通过系统调用(Syscall)连接系统的内核空间与用户空间。用户空间主要采用C++和Java代码，通过JNI技术打通用户空间的Java层和Native层(C&#x2F;C++)。Google官方提...</div></div></div></a><a class="pagination-related" href="/2023/12/13/Android-14-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BWindowManagerService/" title="Android_14_源码分析之WindowManagerService"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-13</div><div class="info-item-2">Android_14_源码分析之WindowManagerService</div></div><div class="info-2"><div class="info-item-1"> 前言    参考博客- &emsp;&emsp;本文中的所有内容大部分来源于网络资料，如有侵权请联系本人修改或删除，请大家多多支持原创!非常感谢！ WindowManagerServiceActivity与Window相关概念 Activity只负责生命周期和事件处理 window只控制视图 一个Activity包含一个Window，如果Activity没有Window，那就相当于Service AMS统一调度所有应用程序的Activity WMS控制所有Window的显示与隐藏以及要显示的位置  Window&emsp;&emsp;“Window” 表明它是和窗口相关的，”窗口“是一个抽象的概念，从用户的角度来讲，它是一个”界面“;从SurfaceFlinger的角度来看，它是一个Layer,承载着和界面有关的数据和属性;从WMS角度来看，它是一个WindowState，用于管理和界面有关的状态。  表示一个窗口的概念，是所有View的直接管理者，任何视图都通过Window呈现(点击事件由Window-&gt;DecorView-&gt;View;Activity的setCo...</div></div></div></a><a class="pagination-related" href="/2023/12/13/Android-14-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BPackageManagerService/" title="Android_14_源码分析之PackageManagerService"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-13</div><div class="info-item-2">Android_14_源码分析之PackageManagerService</div></div><div class="info-2"><div class="info-item-1"> 前言 背负着过去的痛苦，夹杂着现实的烦恼，对人的心灵而言是无任何益处的      参考博客 wise丰 冬子  &emsp;&emsp;本文中的所有内容大部分来源于网络资料，如有侵权请联系本人修改或删除，请大家多多支持原创!非常感谢！ PackageManagerService&emsp;&emsp;PackageManagerService(PMS)主要是管理应用的安装，卸载，更新，解析以及权限。同ActivityManagerService,PMS也是由SystemService孵化而来。   启动与初始化 frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java  12345678910111213141516171819202122232425262728//line 1234// Start the package manager.if (!mRuntimeRestart) &#123;    FrameworkStatsL...</div></div></div></a><a class="pagination-related" href="/2023/11/11/AndroidTv%E9%83%A8%E5%88%86%E9%A1%B5%E9%9D%A2%E6%8C%89%E9%94%AE%E9%9F%B3%E6%97%A0%E6%95%88/" title="AndroidTv部分页面按键音无效"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-11</div><div class="info-item-2">AndroidTv部分页面按键音无效</div></div><div class="info-2"><div class="info-item-1">  Android Tv 部分页面按键音无效，dispatchKeyEvent分发被拦截&emsp;&emsp;开始阅读之前，可以简单了解一下这些大佬的文章。    c枫_撸码的日子   Android 按键处理一 （基础知识） Android 按键处理二 （按键流程之内核层篇） Android 按键处理三 （按键流程之framework）   空杯的境界 Android 按键事件(KeyEvent)的分发机制   小羊子说 Android TV中按键事件和焦点处理总结   圆周率X Android dispatchKeyEvent事件分发详解，简单易懂    问题描述&emsp;&emsp;接入喇叭，进入应用，突然发现一些页面有系统调用的按键提示音，而有些页面则没有。(最终发现是使用了Scrollview出的bug) 问题分析&emsp;&emsp;既然按键声音没有发出，那首先需要了解一下按键声音是怎么发出的。当用户注册了clickListener，则调用发出playSoundEffect()和响应用户写好的onClick()方法。首先排除系统设置声音无效。可以使用adb命令 ...</div></div></div></a><a class="pagination-related" href="/2023/12/13/Android-14-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="Android_14_源码分析之启动流程"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-13</div><div class="info-item-2">Android_14_源码分析之启动流程</div></div><div class="info-2"><div class="info-item-1">   前序  &emsp;&emsp;时间从来不语，却回答了所有问题，岁月从来不言，却见证了所有努力，愿大家遇到困难时都能换乘机遇，踏歌而行时一往无前。 参考资料 Android Framework 开发揭秘  &emsp;&emsp;本文中的所有内容大部分来源于网络资料，如有侵权请联系本人修改或删除，请大家多多支持原创!非常感谢！ 简介&emsp;&emsp;Android 是一种基于 Linux 的开放源代码软件栈，为各类设备和机型而创建。  &emsp;&emsp;Android 平台的基础是Linux内核。例如，Android Runtime(ART)依靠Linux内核来执行底层功能，例如线程和底层内存管理。 Linux 内核 硬件抽象层(HAL)  HAL提供标准界面，向更高级的Java API 框架显示设备硬件功能。   Android Runtime  对于运行在Android 5.5(API 21)以上的设备，每个应用都有自己的ART实例并在其自己的进程中运行。 ART编写为通过执行DEX文件在低内存上运行多个虚拟机。 ART的功能包括 预先AOT和及时JIT，编...</div></div></div></a><a class="pagination-related" href="/2023/11/24/Android%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85-Java/" title="Android第三方网络框架封装-Java"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-24</div><div class="info-item-2">Android第三方网络框架封装-Java</div></div><div class="info-2"><div class="info-item-1">Android第三方网络框架封装-Java 参考文章&#x2F;博主 苏火火 Android进阶： 详解OkHttp+Retrofit+Rxjava实现网络请求 RxJava2+Retrofit2+OkHttp3的基础、封装和项目中的使用    &emsp;&emsp;本文中的所有内容大部分来源于网络资料，如有侵权请联系本人修改或删除，请大家多多支持原创!非常感谢！ 1. 概述&emsp;&emsp;在Android开发中，网络请求是必不可少的一环。最近做了一个需求，类似于应用宝的功能，需要从服务器获取数据，然后展示到界面上。并下载apk文件，实现静默安装。本篇主要介绍自己是如何使用Rxjava、Retrofit、Okhttp等框架，实现网络请求和下载apk的功能。 1.1 OKHttp&emsp;&emsp;OkHttp是一个用于处理HTTP请求的开源Java库，由Square公司开发。对于网络框架，更多的人会想到volley，volley是Android系统自带的网络请求框架。但是volle在Android 5.0之后被Google抛弃了，所以OkHttp逐渐成为Androi...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zj970/resource/personal/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zj970</div><div class="author-info-description">谢谢你在世界的角落找到我</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zj970"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">外向是生活所需，孤独是自我享受</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">适配器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ListView"><span class="toc-number">2.1.</span> <span class="toc-text">ListView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RecyclerView"><span class="toc-number">2.2.</span> <span class="toc-text">RecyclerView</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8RecyclerView%E6%B7%BB%E5%8A%A0%E5%AD%90%E6%8E%A7%E4%BB%B6%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%B4%8A%E4%B9%B1"><span class="toc-number">3.1.</span> <span class="toc-text">使用RecyclerView添加子控件点击响应事件数据紊乱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.</span> <span class="toc-text">延伸学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">复用机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ViewHolder%E7%9A%84%E5%A4%8D%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">2. ViewHolder的复用概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView-%E7%9A%84%E5%A4%8D%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.1.</span> <span class="toc-text">ListView 的复用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView-%E7%9A%84%E5%A4%8D%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.2.</span> <span class="toc-text">RecyclerView 的复用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListView-%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text">ListView 的回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView-%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">4.2.4.</span> <span class="toc-text">RecyclerView 的回收</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/ArchLinux-AOSP-0/" title="AOSP 环境搭建"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17553037581602176.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AOSP 环境搭建"/></a><div class="content"><a class="title" href="/2025/09/20/ArchLinux-AOSP-0/" title="AOSP 环境搭建">AOSP 环境搭建</a><time datetime="2025-09-20T14:41:49.000Z" title="发表于 2025-09-20 22:41:49">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/14/ArchLinuxSunshine/" title="ArchLinuxSunshine"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17165170649320832.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArchLinuxSunshine"/></a><div class="content"><a class="title" href="/2025/09/14/ArchLinuxSunshine/" title="ArchLinuxSunshine">ArchLinuxSunshine</a><time datetime="2025-09-13T17:55:33.000Z" title="发表于 2025-09-14 01:55:33">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/04/Android%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" title="Android之渲染原理"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android之渲染原理"/></a><div class="content"><a class="title" href="/2025/06/04/Android%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" title="Android之渲染原理">Android之渲染原理</a><time datetime="2025-06-03T16:33:51.000Z" title="发表于 2025-06-04 00:33:51">2025-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/25/Debug-JDB/" title="Debug 工具之 JDB"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Debug 工具之 JDB"/></a><div class="content"><a class="title" href="/2025/05/25/Debug-JDB/" title="Debug 工具之 JDB">Debug 工具之 JDB</a><time datetime="2025-05-25T11:24:20.000Z" title="发表于 2025-05-25 19:24:20">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/31/%E7%A6%BB%E5%88%AB2024/" title="离别2024"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/zhou-jian1234/resource/raw/master/paper/comics/17367140004646272.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离别2024"/></a><div class="content"><a class="title" href="/2024/12/31/%E7%A6%BB%E5%88%AB2024/" title="离别2024">离别2024</a><time datetime="2024-12-31T15:59:59.000Z" title="发表于 2024-12-31 23:59:59">2024-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2020 - 2025 By zj970</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'forest'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>